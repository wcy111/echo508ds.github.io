[{"title":"List comprehension","url":"/2021/04/12/list-comprehension/","content":"\n<!-- more -->\n\n最近学习了列表解析式(List comprehension )，它属于Python中的语法糖(Syntactic Sugar)。语法糖的出现主要是为了写程序的时候能少出错并且代码可以更简洁。这篇通过LeetCode的17. Letter Combinations of a Phone Number的一个解法引出这个表达。\n\n---\n\n# 引例\n\n题目不赘述了，给出链接[Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n\n比较认同的一个解法如下:\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> list:\n        graph = {'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z']}\n        ans=['']\n        if digits==\"\":\n            return [] \n        for i in digits:\n            chars.append(graph[i])\n        for i in range(len(chars)):\n            ans=[c+chars[i][j] for c in ans for j in range(len(chars[i]))]\n        return ans\n```\n\n首先字典存储以数字为键对应字母列表为值的一系列item。我们要做的是把所要求的digits对应的可能字母组合全部找出来。\n\n\n\n先把每个数字对应的字母拼接在一个数组里即chars，需要注意的是此时的chars是个二维数组，因此len(chars)返回的为digits的长度,也即组合中任一元素的长度。\n\n\n\n紧接着为了得到可能的所有组合，我们需要显式的去设计循环，而解法中一个列表解析式就完成了所有操作，很简洁也很优雅。具体的逻辑在文末给出。\n\n-----\n\n## 关于List comprehension\n\n当我们定义有内容的list的时候，特别是在放入元素前做一些计算的时候，我们除了使用for 循环来添加列表元素，还可以在列表内直接写解析式计算。\n\n## List comprehension 用法\n\n### 1. [ expression for i in iterable ]\n\n```python\nans=[i+1 for i in range(10)]\nprint('ans:',ans)\n----------------------------\nans: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n对于迭代对象进行加一运算并存放在ans数组中 其中iterable object: range(10) , expression: i+1。\n\n### 2. [ expression for i in iterable if...]\n\n如果我们需要对进入target list中的元素进行筛选，我们可以对迭代表达式的末尾加入if 语句\n\n```python\nans=[i+1 for i in range(10) if i%2==0]\nprint('ans:',ans)\n----------------------------\nans: [1, 3, 5, 7, 9]\n```\n\n之所以选这个例子，是为了使得表达式的逻辑变得更加清晰。通过if语句```if i%2==0```我们选取了0~9中为偶数的元素进行表达运算，+1以后得到```ans: [1, 3, 5, 7, 9]```\n\n### 3. [ expression for i in iterable if… for j in iterable if… …]\n\n更复杂点，双循环+if， 实现了5以内（复数，单数）的所有组合\n\n```python\nans=[(i,j) for i in range(5) if i%2==0 for j in range(5) if j%2==1]\nprint('ans:',ans)\n----------------------------\nans: [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n```\n\n它实现的逻辑如下：\n\n```python\nans=[]\nfor i in range(5):\n    if i%2==1:continue\n    for j in range(5):\n        if j%2==1:ans.append((i,j))\nprint('ans:',ans)\n----------------------------\nans: [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n```\n\n## 小结\n\n可以看出来，事实上列表表达式把显式的for循环和if语句简化了。实际中，expression对每一轮迭代循环结束后得到的元素进行操作。\n\n---\n\n# 回到引例\n\n```python\nfor i in range(len(chars)):\n    ans=[c+chars[i][j] for c in ans for j in range(len(chars[i]))]\n```\n\n这时候回到引例，\n\n{% asset_img Telephone-keypad.png %}\n\n再次强调for循环迭代的次数等于digits字符串的长度，也即最后ans中每个元素的长度。\n\n\n\n接下来分析在每轮迭代中列表解析式究竟做了些什么\n\n## 循环1\n\n首先第一层的循环是对于ans也就是我们target list进行的，变量c存储当前遍历元素。\n\n## 循环2\n\n然后第二层循环是对于 len(chars[i])进行的它返回的是digit中某个数字对应的可能字符个数（如图数字2有3个对应的字母，而数字7和9有4个), 变量j存储当前遍历索引。\n\n---\n\n## 表达式\n\n```c+chars[i][j]```chars[i]表示的是digits中数字的索引，j表示的是该数字对应的可能的字母的索引（对于digits'27',当i=0的时候，j会从0遍历到2;当i=7的时候，j会从0遍历3）。因此，思考下就能得知，实际上，每轮for循环target list中存放的是前i+1个数字的可能的字母组合。列表解析式所实现的双重循环在增加target list中元素的个数的同时通过expression增加元素的长度。\n\n","tags":["Python","List comprehension","LeetCode"],"categories":["Programming","Python","List comprehension"]},{"title":"双指针类型题解（一）","url":"/2021/04/07/双指针类型题解（一）/","content":"\n<!-- more -->\n\n# 快慢指针\n\n大意是把单链表中倒数第n个结点给剔除，链表不同于数组并没有显式的给出长度，也不能简单通过索引定位。因此找到目标结点就需要一些特殊的trick，事实上也有着很多奇妙的解法。但是在这里，快慢指针是比较容易想到也比较高效的解法。快慢指针的方法很简单就是初始化两个指针，在每一轮的迭代中它们移动的步长存在快慢差异。\n\n## 19. Remove Nth Node From End of List\n\n### 思路\n\n对于这题，我们可以让快指针先移动n步，然后再启动慢指针并保持步长为1的同速。最后当快指针到达链表尾结点的时候，停止迭代。因为快指针比慢指针多移动了n步，所以它到达终点时领先了慢指针n步，因此此时慢指针的索引即为我们目标索引。\n\n### 代码\n\n```python\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        fast=slow=head\n        for i in range(n):\n            fast=fast.next\n        if not fast:\n            return head.next # case: n=size\n        while fast.next:\n            fast=fast.next\n            slow=slow.next\n        slow.next=slow.next.next # delete n_th node from end\n        return head\n```\n\n### 谬误与反思\n\n一开始想错了 在上面for i = n+1这会导致溢出, 其次忽略了n=size的情况。\n\n---\n\n## 141. Linked List Cycle\n\n### 思路\n\n题目让判断链表是否存在环，想成操场追击问题，如果有环快指针先进入环，等待慢指针进入环后，想下速度v=2和v=1的俩人在操场跑步，它们一定会相遇的~\n\n### 代码\n\n```python\nclass Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        fast=slow=head\n        while (fast and fast.next):\n            fast=fast.next.next\n            slow=slow.next\n            if fast==slow:\n                return True\n        return False\n```\n\n### 谬误与反思\n\n1. 一开始忽略了[]空链表的情况，Nonetype 没有next attribute的报错。\n\n2. 一开始没有注意到while里的条件，事实上应当是，```  fast and fast.next```。and 短路逻辑运算符则很好的解决了无环情况下最后fast指针是否到达None结点的两种case，防止循环内快指针移动报错。\n\n## 142. Linked List Cycle II\n\n## 思路\n\n{% asset_img image.png %}\n\nquora上比较intuition的解答:\n\n{% asset_img solution_quora.png %}\n\n需要注意的是z的长度可能是z+n*length(circle), n是多少与x和环的长度有关，极端点设想环的长度是1就懂了。\n\n## 代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast=slow=head\n        while (fast and fast.next):\n            fast=fast.next.next\n            slow=slow.next\n            if fast == slow: break\n        if not (fast and fast.next): # if no circle\n            return None\n        while head is not fast:\n            head=head.next\n            fast=fast.next\n        return head\n```\n\n## 谬误与反思\n\n1. 一开始把空链表和单一元素链表的情况拎出去了，导致写的有点繁琐，事实上判断有无环的循环再进行判断这俩case会比较方便。\n\n2. 写判断的时候一开始脑子热了，把not(fast and fast.next)写成 not fast and not fast.next，其实相当于¬((a )∧(b))  ！= ¬a ∧ ¬b，此情景下应该是前者，（离散数学是真的忘光了QAQ）\n\n","tags":["LeetCode","Double pointer","Link list"],"categories":["Programming","LeetCode","Double pointer"]},{"title":"些许记录和感悟 （一）","url":"/2021/04/06/些许记录和感悟/","content":"\n  就这样大学快毕业了，在杭州这座城市也呆了十年。很多事情恍惚间好像还是发生在昨天。我不是一个热衷于表达自我的人，我更倾向于去观察去感受。但是在这个结点我总觉得该写些什么去记录一些过往。可能是想在这梦幻般的二十几年中捕捉一点真实，也可能是想以这个方式分担背负在身上的压抑了很久的情感包袱。这一系列记录也将在我的技术博客中以友谊，爱情，爱好，学习，以及我对人生对这个世界的一些浅薄认知慢慢展开。\n\n## 论友谊\n\n  不知道为什么先是友谊，也许是我最近因此而烦恼吧？关于友谊，我的朋友很少，自然的社交对我来说从来都是一件很具挑战的事情。从小学开始，除了同班同学我很难结识新的朋友。这里需要澄清的一点大概是，并不是说我是一个很恶劣的人。只是过往经历和性格的原因导致我很少去主动认识新朋友，对于那些向我抛出橄榄枝的同学，我经常因为不知所措而冷漠回应，留下了不友好的印象。\n\n\n\n  当然，有时候我也能幸运的交到聊得来玩的开的好朋友，但是对于矛盾误会糟糕的处理以及对于维持关系的疏忽，许多朋友最后都失望离开。**这样的事情仍在发生，我似乎也从未很好吸取教训，讽刺的是直到寂寞再次袭来时才自私的开始意识到朋友的重要性。**\n\n\n\n  重新审视友谊，我发现自己一直以来没有很好理解什是友谊。小时候我总以为友谊是物质上的交互，借给同桌的橡皮擦，得到的生日礼物。后来我发现, 友谊不仅仅是物质上的交互也是情感的交流。“你讲的笑话好好笑”，“你真幽默”，“谢谢你安慰我”诸如此类。再后来，我发现友谊是包容是忍让，是真心真意为对方着想，希望对方可以变得更好并由衷的为此而高兴，是一种比较高级的情感。**它是对等的而不是建立在利益之上的互相利用或者是怜悯施舍对方从中获得优越感**。\n\n\n\n  友谊的敌人是猜疑和嫉妒，这无可厚非，因为人性如此，这是基因所带来的。本质上它们都是一种情绪，有时候超出我们的控制。我深受其害并且十分厌恶这种情绪，因为它野蛮不很优雅，并且它们破坏了很多友谊，也因此让我失去了很多很好的朋友。\n\n\n\n我曾经花了很多时间去留意这种本能的情绪也尝试阅读相关专业的研究。简而言之我倾向于认为，它来源于一种认知冲突，它在比较中将别人拥有而自己未有的落差转换为一种失去或是不得的感受，但是内心却不认可这个比较带来的冲突，为了解决这个冲突，内心进化出一种心理策略来平衡这种认知的矛盾。 这种情绪会在与自己不认可的人的比较中更为强烈。对内，这是一种很强的内耗，对外，它会表现出强的言语或者行为上的攻击性。\n\n\n\n  显而易见，它似乎没有任何益处。但事实上在生活中，甚至是朋友亲人之间这也十分常见，有时候它甚至能支配言语和行动。我清楚的记得，以前交好的一位朋友（带我入英雄联盟深坑的罪魁祸首），我们经常在一起玩一起打游戏，但是每次大小考成绩一出我总是拿自己和他的比较，如果我总分高就开心的不行浑身愉悦，要是低就会变得很低落。有时候很正常的关于学习经验的对话，我总会认为这是他变相的炫耀。终于一次尖锐的言语不由自主的从嘴里说出，面面相觑中，友谊已经出现无法恢复的伤痕。\n\n\n\n  那时候我还意识不到那种心情，直到后来在我取得些许成就之时，满心欢喜分享给好朋友的时候，对方刻薄的回应，我才体会到这是什么滋味，也明白了之前的自己究竟做了些什么蠢事。\n\n\n\n  不断的反思，对于嫉妒/妒忌这类的情感，我认为大方的承认别人的好，感受到自己的不足，虚心的去学习去改变自己才是对的。You only live once, 为什么不能少一点狭隘多一点坦诚呢？\n\n\n\n  友谊有敌人当然也有朋友，我认为友谊的朋友应该是包容和信任，它就像是友谊的修补剂，让接近分崩离析的友谊重新牢固，让其从牢固变得坚不可摧。但这种情感是反本能的，因为包容和信任意味着在受到背叛或者是威胁后选择依然相信。从概率论来说，像是一种条件概率，意味着你受到下次背叛或者威胁的概率将会变得更大。\n\n\n\n  但其实这也是合理的，因为朋友之所以能成为朋友就存在其他互相欣赏的地方。而且人无完人，每个人有自己的境遇有着不同的困惑也分别处在不同的人生阶段，矛盾和误会不可避免，生活的不如意也会将这种情绪放大无数倍。\n\n\n\n  回头望去，一路上其实有不少的朋友包容过我，鼓励过我。他们之中有的已经和我走散了，有的还是我的好朋友。但是不管如何，我都很感激他们，因此往后也希望自己变得更加包容，尝试去信任他人鼓励他人。我想这也是英文中常被提到的Be nice的含义吧。\n\n\n\n  说了这么多，我愈发觉得纯洁的友谊是多么难得多么奢侈的一样东西。所幸，在我屈指可数的朋友之中我还能瞥见它的影子。这也让我更加坚定的让自己变得更好，去珍惜维护它们，不像以前一样再毁了它。\n\n","tags":["Life","Friendship"],"categories":["Life","Record"]},{"title":"Interpretable Machine Learning(LIME-1)","url":"/2021/04/05/Interpretable Machine Learning/","content":"\n## 关于LIME\n因为研究需要，得弄懂kernel SHAP所以先得弄明白LIME，不想这东西还挺有意思的，该算法发表在2016的KDD上，先挂个介绍视频吧。\n\n{% youtube hUnRCxnydCc %}\n视频简单形象介绍了LIME以及该算法的motivation和intuition. 总结一下，我们可以用LIME去1) 在几个旗鼓相当（性能相似）的模型中做选择。2）去鉴别不值得信任的模型并改善。3）从模型中得到新的发现灵感。\n\n具体一点，\n1）的应用主要是在满足metric需要的模型之间找到更适合需求的模型，比如有的模型虽然perform well但是解释性一团糟，又比如有的语言模型涉嫌种族歧视……\n\n2）有一些模型perform beyond expectation，有很大嫌疑发生了data leakage（我就被这个坑惨了），比如说用来鉴别学生属于哪个班级，模型将学生ID作为特征，而由ID可直接推出学生班级。又比如图像领域，识别北极熊和棕熊，模型将雪地背景作为判别image 是否为北极熊的重要特征。这些模型虽然表现的很好但是却毫无意义（本质为过拟合），在部署上线后会变得一塌糊涂。\n\n3）这方面应用就比较灵活了，可以用于异常检测，也可以用于特征选择或者构建新的powerful feature....\n\n## LIME算法\n### IDEA\nLIME（Local Interpretable Model-Agnostic Explanations )属于局部代理模型，是一种可解释的模型用于解释黑盒机器模型对单个实例（individual）的预测。它的想法非常直觉，首先我们仅保留训练好的黑盒模型，然后扰动数据生成新的样本，通过黑盒模型得到这些样本的预测值作为LIME explainer的label，训练LIME explainer，由于explainer对比原来的黑盒模型更加简单，我们可以通过它作为原始黑盒模型的代理对感兴趣的样本点进行解释和分析。\n\n实际上，explainer可以是任何模型，但是因为复杂度的因素，Lasso（linear regression with L1）和decision tree通常被选作explainer.\n\n### Mathematics \n\n数学上，带有模型复杂度（可解释性）正则项限制的局部代理模型\n$$\n\\operatorname{explanation}(x)=\\arg \\min _{g \\in G} L\\left(f, g, \\pi_{x}\\right)+\\Omega(g)\n$$\n其中f函数代表待解释的black-box model, g函数则是在G函数空间中的一个解释性模型，$π_x$代表感兴趣样本x的邻样本范围的大小。\n\n\n\n显然，$π_x$如果越大，则有越多的远离interest point的实例被用于构建local surrogate explainer，可能会引入一些新的解释。其次关于正则项$\\Omega(g)$，我个人的理解是G空间中会有很多在损失函数上表现相当的函数，我们要从中选取那些复杂度低，解释性好的。具体的，该项可以用于heterogeneous models之间的选择，比如决策树和线性模型，也可以用于homogeneous models之间的选择，不同特征数量的线性模型或者不同深度不同叶子节点数目的决策树等....\n\n\n\n但是这里需要注意的是，在实际操作中，我们只对损失函数项进行优化，复杂度的正则项是通过我们预先限制模型的复杂度来得到的。\n\n### Recipe for raining local surrogate models\n\n其算法执行的流程大致如下:\n\n\n1） 选择感兴趣的实例（经由黑盒模型预测的某个实例）\n\n2）扰动数据集（采样）得到新的样本，并输入到黑盒模型中得到其预测值作为其标签。\n\n3）对这些新的样本根据与感兴趣实例的接近程度（类似特征向量的欧氏距离）来进行赋权。\n\n4）基于新的样本训练可解释模型\n\n5）通过可解释模型解释感兴趣的实例\n\n\n\n\n\n","tags":["Machine learning","Interpretable Machine Learning","LIME"],"categories":["Machine learning","Interpretable Machine Learning"]},{"title":"记一次课堂project","url":"/2021/04/05/Lloyd-Max Quantizer/","content":"# PDF资料\n{% pdf ./Max-Floyd.pdf %}\n# 作业要求\n>参考 Max-Floyd.pdf 中的example 2, 将$p(x)$修改成高斯分布$N(0,1)$\n\n# 代码实现\n```python\nimport scipy.stats as stats\nfrom scipy.integrate import quad\nimport math\ny1=0.3;y2=0.8;max_iterations=500;precision=1e-9\n# p=1\n# p=stats.norm.pdf(x,0,1)\nnum_func=lambda x: x*stats.norm.pdf(x,0,1)\nden_func=lambda x: stats.norm.pdf(x,0,1)\nfor i in range(max_iterations):\n    b1=(y1+y2)/2\n    Num1,Nerr1=quad(num_func,0,b1)\n    Den1,Derr1=quad(den_func,0,b1) \n    y1=Num1/Den1\n    Num2,Nerr2=quad(num_func,b1,1)\n    Den2,Derr2=quad(den_func,b1,1) \n    tmp=y2\n    y2=Num2/Den2\n    if abs(y2-tmp)<precision:\n        print('iterations:',i)\n        break\nprint('y1:',y1,'y2:',y2,'b1:',b1)\n```\n\n# 深入思考\n未完待写..","tags":["Machine learning","Python","Optimisation"],"categories":["Machine learning"]},{"title":"神经网络中的数据表示","url":"/2021/04/04/2021神经网络中的数据表示/","content":"\n# 神经网络中的数据表示\n\n矩阵运算加块了神经网络的计算速度，而在应用中数据常常存储在多维Numpy数组中，其也被称为张量(tensor). 当前基本所有机器学习系统都使用张量作为数据结构，它对这个领域尤为的重要，以TensorFlow的命名就可窥见。\n\n张量这一概念的核心在与，它是数据容器。 其中矩阵就是二维张量，张量事实上是矩阵向任意维度的推广。（张量的维度(dimension)常被称作轴(axis)，张量轴的个数被称为阶（rank））\n\n-----\n## 标量（scalar）0D张量\n Numpy中，一个 float32和float64的数字就是一个0D张量。其可用ndim属性来查看。0D张量的ndim==0,如下图所示。\n\n{% asset_img image-20210306204113139.png %}\n\n\n## 向量（vector）1D张量\n\n很多数据中标签是存储在1D张量中的。其形式如下\n\n{% asset_img image-20210306204514761.png %}\n\n\n这个向量中有6个元素，被称为6D向量，易与张量的阶数混淆。事实上6D向量只有一个轴，沿着轴有6个维度(dimensionality)。6D张量才有6个轴。其中，维度既可以表示某个轴上的元素个数，也可以表示张量中的轴数。后者更准确的叫法应该是6阶张量。但是6D张量这种写法常见。\n\n## 矩阵(matrix) 2D张量\n\n向量组成的数组叫矩阵。矩阵有两个轴，通常称为行（row）和列(column)，其形式如下\n\n{% asset_img image-20210306210108337.png %}\n3X2的矩阵\n\n\n## 3D张量\n{% asset_img image-20210306210342187.png %}\n\n以CIFAR10数据集为例\n\n{% asset_img image-20210306210616667.png %}\n\n3D张量分别存储 高度 宽度和颜色深度，其大小为32*32像素，颜色深度维数为3，分别对应RGB三个颜色通道。\n\n\n## 4D张量\n\n关于4D张量：当许多图片累加起来时3D张量就不足以存储，需要增加一个拥有N维的轴来存储N个图片样本。\n\n\n## 5D张量\n\n关于5D张量：其中视频数据可以被看做事5D张量的少数数据类型之一，视频可以被看做由一系列帧（Frame）构成。每一个帧可以保存在一个形状为（height,width,color_depth）的3D向量中，一系列帧可以保存在(frames,height,width,color_depth)的4D张量中，不同视频数据组成的批量可以保存在5D张量中(samples,frames,height,width,color_depth)","tags":["Deep Learning","Data Science"],"categories":["Programming"]}]