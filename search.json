[{"title":"Python补基础（一）","url":"/2021/06/16/Python中的引用/","content":"\n<!-- more -->\n\n一些Python的基础知识，涉及变量、对象、引用、计数、拷贝\n\n## 一些抄下来的废话\n\n-Python为**动态解释性**语言，赋值不需要事先**声明变量**，类型是运行过程中自动决定的\n\n-Python中都是**引用**\n\n-Python中**变量**和**对象**的关系是**引用**\n\n## Python中的变量、对象、引用\n\n### 变量（variable）\n\n- 第一次赋值即创建，再次'赋值'会改变改变的值\n\n- 变量名本身是无类型的，对象才有类型，变量只是引用了对象\n- 变量需要在使用前赋值，否则报错\n\n### 对象（Object）\n\n- 对象有类型\n\n- 对象生成时会得到一块内存空间来存储其值\n\n- 每个对象有两个标准的头部信息\n\n  - 类型标识符：标识对象的类型\n  - 引用计数器：决定是否回收对象\n\n### 引用（Reference）\n\n- Python中**变量**到**对象**的连接叫**引用**\n- **引用**是一种关系，通过**内存**中的**指针**形式实现\n- 赋值操作时，自动建立**变量**和**对象**之间的关系，即引用\n---\n\n**举个栗子**：\n\n  ```python\n  str='hello world'\n  print('type:',type(str),'\\n','value:','\\n',str,'id:',id(str))\n  ```\n\n  得到结果\n\n  ```shell\n  type: <class 'str'> \n  value: \n  hello world id: 140225804592048\n  ```\n\n>type查看对象str的类型标识符，结果为str即字符串类型，value查看对象str的值为'hello world',id用来查看对象的内存地址。\n>\n>赋值语句 ```str='hello world'``` 实际上是做的是，1 -替值为hello world的字符串对象开辟内存地址 2 -变量str引用对象的地址，相当于指针指向str。\n\n## Python标准数据类型\n\n简单介绍了变量，对象和引用的基础知识，接下来介绍下Python中五大标准数据类型\n\nNumbers \n\nString\t\n\nList\n\nTuple\n\nDictionary\n\n- 在python中, String tuple number是不可变数据类型而 list dict是可变数据类型\n\n## 可变对象和不可变对象\n\n可变对象创建之后仍可继续修改，不可变对象则不可修改。具体一点：\n\n- 对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的地址，通俗点说就是原地改变\n\n- 不可变对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址\n\n  \n\n## 赋值、浅拷贝、深拷贝\n\n赋值：对象的引用\n\n浅拷贝：拷贝父对象，不会拷贝对象内部的子对象\n\n深拷贝：完全拷贝对象\n\n----\n\n先占个坑，明天下课回来继续更。\n","tags":["Python"],"categories":["Programing","Python"]},{"title":"终点和意义","url":"/2021/05/22/终点和意义/","content":"\n<!-- more -->\n\n{% meting \"500665339\" \"netease\" \"song\" \"autoplay\" %}\n\n意义困扰了我很多年，第一次意识到人生终点那会，心里真的很害怕，会恐惧也抗拒，那种凝视虚空的感觉让我感受到孤独无助。我甚至会在脑海里想象至亲离世时手握着他们苍白的手亦或是自己年迈衰老濒死之际自己的孩子在病床前守候的场景，就像电影《返老还童》开头渲染那一般。高考前的那段时间以及大学的前几年对终点的恐惧都让我十分挣扎尤其是在独自一人的难眠之夜。\n\n\n\n我觉得这是一件很残酷的事情，因为无论我在人生跑道上漫步或是奔跑领先或是落后，最后都有那么一个终点等着我，到那时无论心中还有多大的执念我也只能放手。可我想一直跑我并不想结束我也害怕结束，甚至贪婪的我还想和我的朋友亲人们一直在一起。但是终点就在那并且丝毫不受任何主观的影响甚至不存在客观上的改变。\n\n\n\n就像美剧《True Detective》中Rust的那段话:“我认为人类的意识是进化过程中的一个可悲的错误，这让我们变得太有自我意识了。自然从自身中抽离出一部分又化为自然，但从自然法则来说我们是不该存在的生物，我们被“拥有自我”这一幻觉给奴役了。因为感官体验和感觉相结合，被设定成让我们相信我们每个人都是某个人，可事实上我们谁都不是。我认为对于所有物种来说，最崇高的事情就是拒绝被设定、停止繁殖、手牵手走向灭亡。”\n\n\n\n个体拥有强烈的自我意识的确是荒谬的，这种强烈的自我意识让我很难过的洒脱，也很难积极投入到现实中，我是多想像《牛氓》中描述的那样“无论我活着，还是死去，我都是一只牛氓，快乐地飞来飞去。”就那么漫无目的的飞来飞去多好啊！\n\n\n\n对终点的思考似乎并不像是突然在我脑海中蹦出，我想这一切应该是归结于那时候自身拒绝社交把自己封闭在自己狭小的舒适圈中，因为曾经在多次目睹人性的恶毒后，精疲力尽，开始对人群和集体有了莫名的恐惧，我主动把自己边缘化了，把自己从集体中抽离出来。也因此我对一系列社会活动不再上心，于是乎那几年感觉自己浑浑噩噩的,靠游戏和动漫麻醉自己。意义的缺失让我感到迷茫，对于大家热衷的GPA，科研，竞赛都让我提不起兴趣来。我只是按部就班完成已经变成习惯的日常。\n\n\n\n那段时间观察身边的人成为了唯一的乐趣，人群中有为了填补心中的自卑感甘愿被虚荣奴役的，也有为了蝇头小利绞尽脑汁去利用别人并为此沾沾自喜的，还有笑里藏刀极尽恶毒的虚伪之人......当然也不乏真诚正直的，善良无所求真心帮助鼓励他人的。但是无论如何，大家好像都很忙碌，似乎身边的人都没有去在意既定的终点。\n\n\n\n一时间感觉自己就像是一个在人来人往的十字街口的幽灵，站在岔路中央，来来往往的行人从我身上穿过，漫无目的游荡的却似乎只有我一个。我想我是我迷失了,在这荒诞的人生中寻找意义就像是缘木求鱼。\n\n\n\n直到经历了很多事情后我才明白，就像臧克家的那句“人生永远追逐幻光，谁把幻光看作幻光，谁便沉入无边苦海” ，也许意义从来不在于意义本身。\n\n\n\n现实的拷打是我摆脱这个桎梏的重大契机，因为我从来不是一个可以从抽象概念之中建立起更高层认知的人，本能的怀疑让我无法专注于其中。本质上，我是那种需要空间和具象的人，我更擅长从实例中去抽象解构概念然后再去构建新的概念。也因此注定了现实和实践才是我摆脱这一牢笼的关键。\n\n\n\n还记得那段时间接连的情感上的挫败，朋友的利用和背叛以及直面残酷的生死离别让我感受到巨大的痛苦。消极情绪将我吞噬，那段时间十分嗜睡，因为梦中的世界还没变的一塌糊涂。可是一旦梦又醒了，一切还是照旧。\n\n\n\n幸运的是，假期里我收到了朋友的一次旅行邀约。是去新西兰，南半球的一个小岛国，也是在那里我见到了更大的世界，体验到了更多的新奇之物。\n\n\n\n那时候，出去看一看的想法开始萌生，也是从那时候我才真正开始对人生开始了模糊的规划，就像是模电中的正反馈。之后一切都开始悄然改变，不断地突破不断地和新的人接触，我体验到了更多，觉得充实。开始慢慢的不去思考人生的意义，也不再去畏惧终点。我找到了自己的路，并且只想坚定的走下去。\n\n\n\n叔本华说生命是一团欲望，欲望得不到满足就痛苦，满足便无聊，人生在痛苦和无聊之间摇摆。而我的欲望仅仅是不断去体验去突破人生的边际罢了。\n\n{% asset_img Newzealand.jpeg %}\n\n","tags":["Life","Meaning"],"categories":["Life","Record"]},{"title":"实验室Linux服务器环境部署(一)","url":"/2021/04/27/实验室Linux服务器环境部署（一)/","content":"\n<!-- more -->\n\n{% asset_img image.png %}\n\n因为并非CS科班，之前少有机会接触这方面的内容，对于计算机的底层架构和Linux都是比较陌生的，因此此篇只浅显介绍下大致原理以及miniconda创建虚拟环境并通过本地jupyter连接远程服务器的流程。\n\n----\n\n## 一、关于服务器\n\n服务器硬件配置如下：\n\n| CPU      | XEON 5115*2                    |\n| -------- | ------------------------------ |\n| 内存     | DDR4 2666 16G*8                |\n| RAID卡   | 2GB SAS RAID卡                 |\n| GPU卡    | NV 2080TI*6                    |\n| 固态硬盘 | 480G 2.5 SATA 6Gb R SSD        |\n| 机械硬盘 | 1.8TB 2.5寸 10K 12Gb SAS硬盘*5 |\n| 电源模块 | 2000W 电源模块X4               |\n\n 操作系统：**Ubuntu 16.04.6 LTS (GNU/Linux 4.15.0-128-generic x86_64)**\n\n每个团队都分配到了账号，管理员在创建目录的时候给每个团队建立了一个主目录，通常在/home下，团队对自己主目录的文件拥有所有权，可以用于进行各种操作。 \n\n```shell\nssh teamn@x.x.x.x\n```\n\n这一步是通过ssh远程连接服务器，其中x.x.x.x是服务器的地址，teamn则是分配到的账号。紧接着会让你输入密码(关于ssh的详细信息可参考[[1](https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)]\n\n```shell\nteamn@x.x.x.x's password: \n```\n\n这里是看不见输入的密码长度的，只需要在键盘上盲打然后按回车就行。密码正确后会显示登录服务器名和账号。可以输入命令**ls**来看当前目录的所有文件，连接时我们处于/home/teamn的用户主目录，我们也可以使用命令**cd ..**返回上级目录或者**cd file_name** (file_name当前目录下某个文件夹的名字)来进入到子目录中。\n\n```shell\nnvidia-smi\n```\n\nBTW上述命令可以查看GPU状态\n\n## 二、在服务器上安装Linux版Anaconda\n\n这里我直接本地下载然后，上传到服务器的目录，然后执行\n\n```shell\nbash Anaconda3-2020.11-Linux-x86_64.sh\n```\n\n进行安装，安装完以后可以输入conda进行验证。\n\n##  三、创建虚拟环境\n\n### -虚拟环境简单介绍\n\n目前我理解的创建虚拟环境的动机主要是 1.不同项目或者库的依赖不同，同一个包在不同项目中对应版本的不同，因此很难兼容，频繁的去upgrade或者downgrade明显过于繁琐。 2. 一个团队大家共用一个账号，如果共用一个环境显然会变得更加混乱。因此创建虚拟环境就十分有必要，使用时激活，环境配置都在激活的环境中进行，环境之间互不影响，并且可以本地或者远程clone别人的环境来进行自己的部署开发。 \n\n事实上，环境管理的工具很多，有virtualenv, Pipenv, conda,docker等。我们熟知的pip是包管理工具, virtualenv可以管理环境。而conda两者兼有，因此这里我们使用conda,conda还有miniconda，其中后者更加轻便。\n\n### -创建环境\n\n这里只介绍几种简单用法，具体可以参考官方文档[[2](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-with-commands)]\n\n创建名为myenv的环境\n```shell\nconda create --name myenv\n```\n创建默认环境带python为3.6版本\n```shell\nconda create -n myenv python=3.6\n```\n创建带有scipy库的默认环境\n```shell\nconda create -n myenv scipy\nor\nconda create -n myenv python\nconda install -n myenv scipy\n```\n\n### -常用命令\n\n```conda list```\n\n类似于pip list,可以查看当前环境目录安装的所有库\n\n```conda info -e```\n\n查看创建的所有环境，会显示所有环境的名字\n\n```conda activate env_name```\n\n激活环境, env_name是环境的名字\n\n```conda deactivate env_name```\n\n关闭环境\n\n## 四、本地连接服务器端Jupyter notebook\n\n这里简述实现流程，具体内容也可参考官方文档[[3](https://jupyter-notebook.readthedocs.io/en/stable/public_server.html)]\n\n### - 在服务器端配置jupyter configuration\n\n**第一步,**生成jupyter笔记本的默认配置文件，如果已经存在会提示你是否要初始化。\n\n```shell\njupyter notebook --generate-config\n```\n\n**第二步，**设置笔记本的登录密码(免密登录的设置参考官方文档)\n\n```shell\njupyter notebook password\n---------------------------\nEnter password:  ****\nVerify password: ****\n[NotebookPasswordApp] Wrote hashed password to /Users/you/.jupyter/jupyter_notebook_config.json\n```\n\n**第三步，**修改jupyter笔记本配置文件，用文本编辑器打开jupyter_notebook_config.py文件，将其中对应行注释符#去掉修改字段或者直接在文件任一位置添加:\n\n```shell\nc.NotebookApp.ip = '*'\nc.NotebookApp.open_browser = False\n```\n\n这里文本编辑器使用vim.关于vim的操作可以参考[4](https://www.ruanyifeng.com/blog/2018/09/vimrc.html)\n\n### - 在服务器端开启jupyter server\n\n 完成基本设置好，然后在中bash输入\n\n```jupyter notebook  ```\n\n默认的端口为8888，但是有时候已经有人使用了该端口，为了避免冲突可以指定开启端口号\n\n```shell\njupyter notebook --port YYYY(四位任意)\n```\n\n如果在本机这样操作会直接在浏览器跳出jupyter web页面，在服务器端因为没有GUI并且在config中设置了 no browser，因此  bash 会提示server 运行在B端口。接下来我们就可以放着先不管了。\n\n### -创建本地到服务器端的映射\n\n事实上也可以改jupyter config的一些配置，直接远程访问该jupyter（remote address:YYYY），这里由于某些原因我失败了暂时选择了如下方法。\n\n在本地终端输入:\n\n```ssh -N -f -L localhost:XXXX:localhost:YYYY  team6@192.168.156.31```\n\n-N 告诉SSH没有命令要被远程执行\n\n-f 告诉SSH在后台执行\n\n-L 指定port forwarding的配置 远程端口是YYYY 本地是XXXX\n\n相当于一个映射，把服务器地址映射到 localhost的一个端口。\n\n---\n\n随后打开任意浏览器地址栏输入localhost:XXXX并输入密码 xxxx（这是我之前在jupyter config里设置的）,即可进入 。\n\n这里如果我们想在jupyter上运行Shell命令，只需要在代码运行的cell前面加! ,   如果需要交互 可以在末尾加--yes 或者-- yes *\n\n## 五、上传下载文件\n\n如果是使用了远程终端软件，图形界面内自备了可视化接口就可方便上传下载文件。在bash中我们可以使用shell命令scp进行操作。\n\nscp local_dir teamn@192.168.x.x:remote_dir\n\n## References\n\n[1]https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\n\n[2]https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-with-commands\n\n[3]https://jupyter-notebook.readthedocs.io/en/stable/public_server.html\n\n[4]https://www.ruanyifeng.com/blog/2018/09/vimrc.html","tags":["Linux","Server","Environment"],"categories":["Linux","Server"]},{"title":"Lambda function","url":"/2021/04/23/Lambda-function/","content":"\n<!-- more -->\n\n## Basic idea\n\n第一次接触到匿名函数还是在学JAVA的时候，它能让代码变得简洁(pithy anonymity )。在Python中其主要是由保留字(keyword)中的Lambda实现的。它的原理很简单，但是有很多用法，配合其他的语法往往有奇效。\n\n\n\n事实上，在之前的博文{% post_link 'Lloyd-Max Quantizer' %}中代码实现部分的第7，8行就使用到了这个表达，当时的context是要对一个服从正态分布的随机变量进行积分，而积分函数quad需要输入积分形式的参数以进行积分。显然，lambda表达式让代码变得十分简洁易读。\n\n---\n\n{% asset_img lambda.png %}\n\n上图官方doc对Lambda的介绍，lambda_expr用来声明匿名函数，然后```lambda parameters: expression```语句为其生成一个函数对象，它与上图中def函数作用相同。\n\n## Usage\n\n下面简单介绍下常见的用法\n\n## 1. 单一参数\n\n实现2*x+1的运算\n\n```python\ndef f(x):\n  return x*2+1\nprint(f)\nprint(lambda x: x*2+1)\nprint('def way:',f(2))\nprint('lambda way',(lambda x: x*2+1)(2))\ng=lambda x: x*2+1\nprint(g(2))\n-----------------------------------------------\n# output\n'<function f at 0x7f4cbe4d2050>'\n'<function <lambda> at 0x7f4cbe4d2440>'\n'def way: 5'\n'lambda way: 5'\n'5'\n\n```\n\n通过上图，可以看到lambda表达式开辟了一个函数空间，我们可以选择赋予其一个函数名比如上面的g，也可以直接使用如表达式```(lambda x: x*2+1)(2)```\n\n---\n\n## 2. 多参数或者无参数\n\n### 多参数\n\n实现名和姓的合并输出\n\n```python\nname=lambda fn,ln: fn.strip().title()+\" \"+ln.strip().title()\nprint(name('LAST  ','   XUAN'),'\\n',name('shiny  ','   ruo'))\n-----------------------------------------------\n# output\n'Last Xuan'\n'Shiny Ruo'\n```\n\n其中strip和title是为了自动纠正不规范输入的函数，前者去掉内容收尾冗余的空格后者让首字母大写其余小写。\n\n### 无参数\n\nlambda表达式不添加参数，相当于过程函数，函数执行函数体内的句子但不返回任何值。\n\n```python\nprocess_func=lambda : print('nothing to return')\nprocess_func()\n-----------------------------------------------\n# output\n'nothing to return'\n```\n\n### 内嵌于其他函数\n\n事实上函数也可以作为函数的参数，一开始quad函数就是这种情况的一个实例。这种情况下所需的函数往往并不是很复杂，但是又需要有一定的灵活性，那么lambda函数就显得很便捷。如常用的sort,filter,map,reduce等，具体的用法在下一次更新~\n\n\n\n","tags":["Python","Lambda function"],"categories":["Programming","Python","Lambda function"]},{"title":"Interpretable Machine Learning(LIME-1)","url":"/2021/04/15/Interpretable Machine Learning/","content":"\n## 关于LIME\n因为研究需要，得弄懂kernel SHAP所以先得弄明白LIME，不想这东西还挺有意思的，该算法发表在2016的KDD上，先挂个介绍视频吧。\n\n{% youtube hUnRCxnydCc %}\n视频简单形象介绍了LIME以及该算法的motivation和intuition. 总结一下，我们可以用LIME去1) 在几个旗鼓相当（性能相似）的模型中做选择。2）去鉴别不值得信任的模型并改善。3）从模型中得到新的发现灵感。\n\n具体一点，\n1）的应用主要是在满足metric需要的模型之间找到更适合需求的模型，比如有的模型虽然perform well但是解释性一团糟，又比如有的语言模型涉嫌种族歧视……\n\n2）有一些模型perform beyond expectation，有很大嫌疑发生了data leakage（我就被这个坑惨了），比如说用来鉴别学生属于哪个班级，模型将学生ID作为特征，而由ID可直接推出学生班级。又比如图像领域，识别北极熊和棕熊，模型将雪地背景作为判别image 是否为北极熊的重要特征。这些模型虽然表现的很好但是却毫无意义（本质为过拟合），在部署上线后会变得一塌糊涂。\n\n3）这方面应用就比较灵活了，可以用于异常检测，也可以用于特征选择或者构建新的powerful feature....\n\n## LIME算法\n### IDEA\nLIME（Local Interpretable Model-Agnostic Explanations )属于局部代理模型，是一种可解释的模型用于解释黑盒机器模型对单个实例（individual）的预测。它的想法非常直觉，首先我们仅保留训练好的黑盒模型，然后扰动数据生成新的样本，通过黑盒模型得到这些样本的预测值作为LIME explainer的label，训练LIME explainer，由于explainer对比原来的黑盒模型更加简单，我们可以通过它作为原始黑盒模型的代理对感兴趣的样本点进行解释和分析。\n\n实际上，explainer可以是任何模型，但是因为复杂度的因素，Lasso（linear regression with L1）和decision tree通常被选作explainer.\n\n### Mathematics \n\n数学上，带有模型复杂度（可解释性）正则项限制的局部代理模型\n$$\n\\operatorname{explanation}(x)=\\arg \\min _{g \\in G} L\\left(f, g, \\pi_{x}\\right)+\\Omega(g)\n$$\n其中f函数代表待解释的black-box model, g函数则是在G函数空间中的一个解释性模型，$π_x$代表感兴趣样本x的邻样本范围的大小。\n\n\n\n显然，$π_x$如果越大，则有越多的远离interest point的实例被用于构建local surrogate explainer，可能会引入一些新的解释。其次关于正则项$\\Omega(g)$，我个人的理解是G空间中会有很多在损失函数上表现相当的函数，我们要从中选取那些复杂度低，解释性好的。具体的，该项可以用于heterogeneous models之间的选择，比如决策树和线性模型，也可以用于homogeneous models之间的选择，不同特征数量的线性模型或者不同深度不同叶子节点数目的决策树等....\n\n\n\n但是这里需要注意的是，在实际操作中，我们只对损失函数项进行优化，复杂度的正则项是通过我们预先限制模型的复杂度来得到的。\n\n### Recipe for raining local surrogate models\n\n其算法执行的流程大致如下:\n\n\n1） 选择感兴趣的实例（经由黑盒模型预测的某个实例）\n\n2）扰动数据集（采样）得到新的样本，并输入到黑盒模型中得到其预测值作为其标签。\n\n3）对这些新的样本根据与感兴趣实例的接近程度（类似特征向量的欧氏距离）来进行赋权。\n\n4）基于新的样本训练可解释模型\n\n5）通过可解释模型解释感兴趣的实例\n\n\n\n\n\n","tags":["Machine learning","Interpretable Machine Learning","LIME"],"categories":["Machine learning","Interpretable Machine Learning"]},{"title":"List comprehension","url":"/2021/04/12/list-comprehension/","content":"\n<!-- more -->\n\n最近学习了列表解析式(List comprehension )，它属于Python中的语法糖(Syntactic Sugar)。语法糖的出现主要是为了写程序的时候能少出错并且代码可以更简洁。这篇通过LeetCode的17. Letter Combinations of a Phone Number的一个解法引出这个表达。\n\n---\n\n# 引例\n\n题目不赘述了，给出链接[Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n\n比较认同的一个解法如下:\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> list:\n        graph = {'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z']}\n        ans=['']\n        if digits==\"\":\n            return [] \n        for i in digits:\n            chars.append(graph[i])\n        for i in range(len(chars)):\n            ans=[c+chars[i][j] for c in ans for j in range(len(chars[i]))]\n        return ans\n```\n\n首先字典存储以数字为键对应字母列表为值的一系列item。我们要做的是把所要求的digits对应的可能字母组合全部找出来。\n\n\n\n先把每个数字对应的字母拼接在一个数组里即chars，需要注意的是此时的chars是个二维数组，因此len(chars)返回的为digits的长度,也即组合中任一元素的长度。\n\n\n\n紧接着为了得到可能的所有组合，我们需要显式的去设计循环，而解法中一个列表解析式就完成了所有操作，很简洁也很优雅。具体的逻辑在文末给出。\n\n-----\n\n## 关于List comprehension\n\n当我们定义有内容的list的时候，特别是在放入元素前做一些计算的时候，我们除了使用for 循环来添加列表元素，还可以在列表内直接写解析式计算。\n\n## List comprehension 用法\n\n### 1. [ expression for i in iterable ]\n\n```python\nans=[i+1 for i in range(10)]\nprint('ans:',ans)\n----------------------------\nans: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n对于迭代对象进行加一运算并存放在ans数组中 其中iterable object: range(10) , expression: i+1。\n\n### 2. [ expression for i in iterable if...]\n\n如果我们需要对进入target list中的元素进行筛选，我们可以对迭代表达式的末尾加入if 语句\n\n```python\nans=[i+1 for i in range(10) if i%2==0]\nprint('ans:',ans)\n----------------------------\nans: [1, 3, 5, 7, 9]\n```\n\n之所以选这个例子，是为了使得表达式的逻辑变得更加清晰。通过if语句```if i%2==0```我们选取了0~9中为偶数的元素进行表达运算，+1以后得到```ans: [1, 3, 5, 7, 9]```\n\n### 3. [ expression for i in iterable if… for j in iterable if… …]\n\n更复杂点，双循环+if， 实现了5以内（复数，单数）的所有组合\n\n```python\nans=[(i,j) for i in range(5) if i%2==0 for j in range(5) if j%2==1]\nprint('ans:',ans)\n----------------------------\nans: [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n```\n\n它实现的逻辑如下：\n\n```python\nans=[]\nfor i in range(5):\n    if i%2==1:continue\n    for j in range(5):\n        if j%2==1:ans.append((i,j))\nprint('ans:',ans)\n----------------------------\nans: [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n```\n\n## 小结\n\n可以看出来，事实上列表表达式把显式的for循环和if语句简化了。实际中，expression对每一轮迭代循环结束后得到的元素进行操作。\n\n---\n\n# 回到引例\n\n```python\nfor i in range(len(chars)):\n    ans=[c+chars[i][j] for c in ans for j in range(len(chars[i]))]\n```\n\n这时候回到引例，\n\n{% asset_img Telephone-keypad.png %}\n\n再次强调for循环迭代的次数等于digits字符串的长度，也即最后ans中每个元素的长度。\n\n\n\n接下来分析在每轮迭代中列表解析式究竟做了些什么\n\n## 循环1\n\n首先第一层的循环是对于ans也就是我们target list进行的，变量c存储当前遍历元素。\n\n## 循环2\n\n然后第二层循环是对于 len(chars[i])进行的它返回的是digit中某个数字对应的可能字符个数（如图数字2有3个对应的字母，而数字7和9有4个), 变量j存储当前遍历索引。\n\n---\n\n## 表达式\n\n```c+chars[i][j]```chars[i]表示的是digits中数字的索引，j表示的是该数字对应的可能的字母的索引（对于digits'27',当i=0的时候，j会从0遍历到2;当i=7的时候，j会从0遍历3）。因此，思考下就能得知，实际上，每轮for循环target list中存放的是前i+1个数字的可能的字母组合。列表解析式所实现的双重循环在增加target list中元素的个数的同时通过expression增加元素的长度。\n\n","tags":["Python","List comprehension","LeetCode"],"categories":["Programming","Python","List comprehension"]},{"title":"双指针类型题解（一）","url":"/2021/04/07/双指针类型题解（一）/","content":"\n<!-- more -->\n\n# 快慢指针\n\n大意是把单链表中倒数第n个结点给剔除，链表不同于数组并没有显式的给出长度，也不能简单通过索引定位。因此找到目标结点就需要一些特殊的trick，事实上也有着很多奇妙的解法。但是在这里，快慢指针是比较容易想到也比较高效的解法。快慢指针的方法很简单就是初始化两个指针，在每一轮的迭代中它们移动的步长存在快慢差异。\n\n## 19. Remove Nth Node From End of List\n\n### 思路\n\n对于这题，我们可以让快指针先移动n步，然后再启动慢指针并保持步长为1的同速。最后当快指针到达链表尾结点的时候，停止迭代。因为快指针比慢指针多移动了n步，所以它到达终点时领先了慢指针n步，因此此时慢指针的索引即为我们目标索引。\n\n### 代码\n\n```python\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        fast=slow=head\n        for i in range(n):\n            fast=fast.next\n        if not fast:\n            return head.next # case: n=size\n        while fast.next:\n            fast=fast.next\n            slow=slow.next\n        slow.next=slow.next.next # delete n_th node from end\n        return head\n```\n\n### 谬误与反思\n\n一开始想错了 在上面for i = n+1这会导致溢出, 其次忽略了n=size的情况。\n\n---\n\n## 141. Linked List Cycle\n\n### 思路\n\n题目让判断链表是否存在环，想成操场追击问题，如果有环快指针先进入环，等待慢指针进入环后，想下速度v=2和v=1的俩人在操场跑步，它们一定会相遇的~\n\n### 代码\n\n```python\nclass Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        fast=slow=head\n        while (fast and fast.next):\n            fast=fast.next.next\n            slow=slow.next\n            if fast==slow:\n                return True\n        return False\n```\n\n### 谬误与反思\n\n1. 一开始忽略了[]空链表的情况，Nonetype 没有next attribute的报错。\n\n2. 一开始没有注意到while里的条件，事实上应当是，```  fast and fast.next```。and 短路逻辑运算符则很好的解决了无环情况下最后fast指针是否到达None结点的两种case，防止循环内快指针移动报错。\n\n## 142. Linked List Cycle II\n\n## 思路\n\n{% asset_img image.png %}\n\nquora上比较intuition的解答:\n\n{% asset_img solution_quora.png %}\n\n需要注意的是z的长度可能是z+n*length(circle), n是多少与x和环的长度有关，极端点设想环的长度是1就懂了。\n\n## 代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast=slow=head\n        while (fast and fast.next):\n            fast=fast.next.next\n            slow=slow.next\n            if fast == slow: break\n        if not (fast and fast.next): # if no circle\n            return None\n        while head is not fast:\n            head=head.next\n            fast=fast.next\n        return head\n```\n\n## 谬误与反思\n\n1. 一开始把空链表和单一元素链表的情况拎出去了，导致写的有点繁琐，事实上判断有无环的循环再进行判断这俩case会比较方便。\n\n2. 写判断的时候一开始脑子热了，把not(fast and fast.next)写成 not fast and not fast.next，其实相当于¬((a )∧(b))  ！= ¬a ∧ ¬b，此情景下应该是前者，（离散数学是真的忘光了QAQ）\n\n","tags":["LeetCode","Double pointer","Link list"],"categories":["Programming","LeetCode","Double pointer"]},{"title":"关于友谊","url":"/2021/04/06/些许记录和感悟/","content":"\n  就这样大学快毕业了，在杭州这座城市也呆了十年。很多事情恍惚间好像还是发生在昨天。我不是一个热衷于表达自我的人，我更倾向于去观察去感受。但是在这个结点我总觉得该写些什么去记录一些过往。可能是想在这梦幻般的二十几年中捕捉一点真实，也可能是想以这个方式分担背负在身上的压抑了很久的情感包袱。这一系列记录也将在我的技术博客中以友谊，爱情，爱好，学习，以及我对人生对这个世界的一些浅薄认知慢慢展开。\n\n## 论友谊\n\n  不知道为什么先是友谊，也许是我最近因此而烦恼吧？关于友谊，我的朋友很少，自然的社交对我来说从来都是一件很具挑战的事情。从小学开始，除了同班同学我很难结识新的朋友。这里需要澄清的一点大概是，并不是说我是一个很恶劣的人。只是过往经历和性格的原因导致我很少去主动认识新朋友，对于那些向我抛出橄榄枝的同学，我经常因为不知所措而冷漠回应，留下了不友好的印象。\n\n\n\n  当然，有时候我也能幸运的交到聊得来玩的开的好朋友，但是对于矛盾误会糟糕的处理以及对于维持关系的疏忽，许多朋友最后都失望离开。**这样的事情仍在发生，我似乎也从未很好吸取教训，讽刺的是直到寂寞再次袭来时才自私的开始意识到朋友的重要性。**\n\n\n\n  重新审视友谊，我发现自己一直以来没有很好理解什是友谊。小时候我总以为友谊是物质上的交互，借给同桌的橡皮擦，得到的生日礼物。后来我发现, 友谊不仅仅是物质上的交互也是情感的交流。“你讲的笑话好好笑”，“你真幽默”，“谢谢你安慰我”诸如此类。再后来，我发现友谊是包容是忍让，是真心真意为对方着想，希望对方可以变得更好并由衷的为此而高兴，是一种比较高级的情感。**它是对等的而不是建立在利益之上的互相利用或者是怜悯施舍对方从中获得优越感**。\n\n\n\n  友谊的敌人是猜疑和嫉妒，这无可厚非，因为人性如此，这是基因所带来的。本质上它们都是一种情绪，有时候超出我们的控制。我深受其害并且十分厌恶这种情绪，因为它野蛮不很优雅，并且它们破坏了很多友谊，也因此让我失去了很多很好的朋友。\n\n\n\n我曾经花了很多时间去留意这种本能的情绪也尝试阅读相关专业的研究。简而言之我倾向于认为，它来源于一种认知冲突，它在比较中将别人拥有而自己未有的落差转换为一种失去或是不得的感受，但是内心却不认可这个比较带来的冲突，为了解决这个冲突，内心进化出一种心理策略来平衡这种认知的矛盾。 这种情绪会在与自己不认可的人的比较中更为强烈。对内，这是一种很强的内耗，对外，它会表现出强的言语或者行为上的攻击性。\n\n\n\n  显而易见，它似乎没有任何益处。但事实上在生活中，甚至是朋友亲人之间这也十分常见，有时候它甚至能支配言语和行动。我清楚的记得，以前交好的一位朋友（带我入英雄联盟深坑的罪魁祸首），我们经常在一起玩一起打游戏，但是每次大小考成绩一出我总是拿自己和他的比较，如果我总分高就开心的不行浑身愉悦，要是低就会变得很低落。有时候很正常的关于学习经验的对话，我总会认为这是他变相的炫耀。终于一次尖锐的言语不由自主的从嘴里说出，面面相觑中，友谊已经出现无法恢复的伤痕。\n\n\n\n  那时候我还意识不到那种心情，直到后来在我取得些许成就之时，满心欢喜分享给好朋友的时候，对方刻薄的回应，我才体会到这是什么滋味，也明白了之前的自己究竟做了些什么蠢事。\n\n\n\n  不断的反思，对于嫉妒/妒忌这类的情感，我认为大方的承认别人的好，感受到自己的不足，虚心的去学习去改变自己才是对的。You only live once, 为什么不能少一点狭隘多一点坦诚呢？\n\n\n\n  友谊有敌人当然也有朋友，我认为友谊的朋友应该是包容和信任，它就像是友谊的修补剂，让接近分崩离析的友谊重新牢固，让其从牢固变得坚不可摧。但这种情感是反本能的，因为包容和信任意味着在受到背叛或者是威胁后选择依然相信。从概率论来说，像是一种条件概率，意味着你受到下次背叛或者威胁的概率将会变得更大。\n\n\n\n  但其实这也是合理的，因为朋友之所以能成为朋友就存在其他互相欣赏的地方。而且人无完人，每个人有自己的境遇有着不同的困惑也分别处在不同的人生阶段，矛盾和误会不可避免，生活的不如意也会将这种情绪放大无数倍。\n\n\n\n  回头望去，一路上其实有不少的朋友包容过我，鼓励过我。他们之中有的已经和我走散了，有的还是我的好朋友。但是不管如何，我都很感激他们，因此往后也希望自己变得更加包容，尝试去信任他人鼓励他人。我想这也是英文中常被提到的Be nice的含义吧。\n\n\n\n  说了这么多，我愈发觉得纯洁的友谊是多么难得多么奢侈的一样东西。所幸，在我屈指可数的朋友之中我还能瞥见它的影子。这也让我更加坚定的让自己变得更好，去珍惜维护它们，不像以前一样再毁了它。\n\n","tags":["Life","Friendship"],"categories":["Life","Record"]},{"title":"Lloyd-Max Quantizer","url":"/2021/04/05/Lloyd-Max Quantizer/","content":"# PDF资料\n{% pdf ./Max-Floyd.pdf %}\n# 作业要求\n>参考 Max-Floyd.pdf 中的example 2, 将$p(x)$修改成高斯分布$N(0,1)$\n\n# 代码实现\n```python\nimport scipy.stats as stats\nfrom scipy.integrate import quad\nimport math\ny1=0.3;y2=0.8;max_iterations=500;precision=1e-9\n# p=1\n# p=stats.norm.pdf(x,0,1)\nnum_func=lambda x: x*stats.norm.pdf(x,0,1)\nden_func=lambda x: stats.norm.pdf(x,0,1)\nfor i in range(max_iterations):\n    b1=(y1+y2)/2\n    Num1,Nerr1=quad(num_func,0,b1)\n    Den1,Derr1=quad(den_func,0,b1) \n    y1=Num1/Den1\n    Num2,Nerr2=quad(num_func,b1,1)\n    Den2,Derr2=quad(den_func,b1,1) \n    tmp=y2\n    y2=Num2/Den2\n    if abs(y2-tmp)<precision:\n        print('iterations:',i)\n        break\nprint('y1:',y1,'y2:',y2,'b1:',b1)\n```\n\n# 深入思考\n未完待写..","tags":["Machine learning","Python","Optimisation"],"categories":["Machine learning"]},{"title":"神经网络中的数据表示","url":"/2021/04/04/2021神经网络中的数据表示/","content":"\n# 神经网络中的数据表示\n\n矩阵运算加块了神经网络的计算速度，而在应用中数据常常存储在多维Numpy数组中，其也被称为张量(tensor). 当前基本所有机器学习系统都使用张量作为数据结构，它对这个领域尤为的重要，以TensorFlow的命名就可窥见。\n\n张量这一概念的核心在与，它是数据容器。 其中矩阵就是二维张量，张量事实上是矩阵向任意维度的推广。（张量的维度(dimension)常被称作轴(axis)，张量轴的个数被称为阶（rank））\n\n-----\n## 标量（scalar）0D张量\n Numpy中，一个 float32和float64的数字就是一个0D张量。其可用ndim属性来查看。0D张量的ndim==0,如下图所示。\n\n{% asset_img image-20210306204113139.png %}\n\n\n## 向量（vector）1D张量\n\n很多数据中标签是存储在1D张量中的。其形式如下\n\n{% asset_img image-20210306204514761.png %}\n\n\n这个向量中有6个元素，被称为6D向量，易与张量的阶数混淆。事实上6D向量只有一个轴，沿着轴有6个维度(dimensionality)。6D张量才有6个轴。其中，维度既可以表示某个轴上的元素个数，也可以表示张量中的轴数。后者更准确的叫法应该是6阶张量。但是6D张量这种写法常见。\n\n## 矩阵(matrix) 2D张量\n\n向量组成的数组叫矩阵。矩阵有两个轴，通常称为行（row）和列(column)，其形式如下\n\n{% asset_img image-20210306210108337.png %}\n3X2的矩阵\n\n\n## 3D张量\n{% asset_img image-20210306210342187.png %}\n\n以CIFAR10数据集为例\n\n{% asset_img image-20210306210616667.png %}\n\n3D张量分别存储 高度 宽度和颜色深度，其大小为32*32像素，颜色深度维数为3，分别对应RGB三个颜色通道。\n\n\n## 4D张量\n\n关于4D张量：当许多图片累加起来时3D张量就不足以存储，需要增加一个拥有N维的轴来存储N个图片样本。\n\n\n## 5D张量\n\n关于5D张量：其中视频数据可以被看做事5D张量的少数数据类型之一，视频可以被看做由一系列帧（Frame）构成。每一个帧可以保存在一个形状为（height,width,color_depth）的3D向量中，一系列帧可以保存在(frames,height,width,color_depth)的4D张量中，不同视频数据组成的批量可以保存在5D张量中(samples,frames,height,width,color_depth)","tags":["Deep Learning","Data Science"],"categories":["Programming"]}]